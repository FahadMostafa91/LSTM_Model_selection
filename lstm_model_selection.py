# -*- coding: utf-8 -*-
"""LSTM_Model_Selection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wp3ToLAbl30WWgs8edk_WflNWGYE-431
"""

import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from copy import deepcopy

# Define a simple LSTM model
class LSTMNet(nn.Module):
    def __init__(self, input_size, hidden_size, output_size=1):
        super(LSTMNet, self).__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, batch_first=True)
        self.fc = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        _, (hn, _) = self.lstm(x)
        out = self.fc(hn[-1])
        return out

# BIC calculation
def compute_bic(loss, n_samples, n_params):
    return n_samples * np.log(loss / n_samples) + n_params * np.log(n_samples)

# Algorithm 1: Fit candidate model with multiple initializations
def fit_candidate_model(X, y, input_size, hidden_size, ninit=5, epochs=10, lr=0.01):
    best_model = None
    best_loss = float('inf')

    for _ in range(ninit):
        model = LSTMNet(input_size, hidden_size)
        optimizer = optim.Adam(model.parameters(), lr=lr)
        criterion = nn.MSELoss()

        for epoch in range(epochs):
            model.train()
            optimizer.zero_grad()
            output = model(X)
            loss = criterion(output.squeeze(), y)
            loss.backward()
            optimizer.step()

        final_loss = loss.item()
        if final_loss < best_loss:
            best_loss = final_loss
            best_model = deepcopy(model)

    n_params = sum(p.numel() for p in best_model.parameters() if p.requires_grad)
    bic = compute_bic(best_loss, len(y), n_params)
    return best_model, bic

# Algorithm 2: Hidden-node selection
def hidden_node_selection(X, y, input_size, q_candidates, ninit=5):
    best_bic = float('inf')
    best_q = None
    for q in q_candidates:
        _, bic = fit_candidate_model(X, y, input_size, q, ninit=ninit)
        if bic < best_bic:
            best_bic = bic
            best_q = q
    return best_q

# Algorithm 3: Input-node selection (drop step only)
def input_node_selection(X_full, y, selected_inputs, hidden_size, ninit=5):
    improved = True
    X = X_full[:, :, selected_inputs]
    while improved:
        improved = False
        for i in selected_inputs:
            trial_inputs = [j for j in selected_inputs if j != i]
            X_trial = X_full[:, :, trial_inputs]
            _, bic = fit_candidate_model(X_trial, y, len(trial_inputs), hidden_size, ninit=ninit)
            _, current_bic = fit_candidate_model(X, y, len(selected_inputs), hidden_size, ninit=ninit)
            if bic < current_bic:
                selected_inputs = trial_inputs
                X = X_trial
                improved = True
                break
    return selected_inputs

# Algorithm 4: Full Model Selection
def model_selection(X_full, y, qmax=10, ninit=5):
    pmax = X_full.shape[2]
    selected_inputs = list(range(pmax))

    # Step 1: Hidden-node selection
    X_sub = X_full[:, :, selected_inputs]
    q = hidden_node_selection(X_sub, y, len(selected_inputs), list(range(1, qmax+1)), ninit=ninit)

    # Step 2: Input-node selection
    selected_inputs = input_node_selection(X_full, y, selected_inputs, q, ninit=ninit)

    # Step 3: Fine-tuning (alternating)
    improved = True
    while improved:
        improved = False

        # Try modifying hidden nodes
        for delta in [-1, 1]:
            q_trial = q + delta
            if 1 <= q_trial <= qmax:
                X_sub = X_full[:, :, selected_inputs]
                _, bic_trial = fit_candidate_model(X_sub, y, len(selected_inputs), q_trial, ninit=ninit)
                _, bic_current = fit_candidate_model(X_sub, y, len(selected_inputs), q, ninit=ninit)
                if bic_trial < bic_current:
                    q = q_trial
                    improved = True
                    break

        # Try dropping inputs
        new_inputs = input_node_selection(X_full, y, selected_inputs, q, ninit=ninit)
        if set(new_inputs) != set(selected_inputs):
            selected_inputs = new_inputs
            improved = True

    return selected_inputs, q